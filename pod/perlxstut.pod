=head1 NAME

perlXStut - Tutorial for XSUB's

=head1 DESCRIPTION

This tutorial will educate the reader on the steps involved in creating
a Perl extension.  The reader is assumed to have access to L<perlguts> and
L<perlxs>.

This tutorial starts with very simple examples and becomes more complex,
with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.

=head2 VERSION CAVEAT

This tutorial tries hard to keep up with the latest development versions
of Perl.  This often means that it is sometimes in advance of the latest
released version of Perl, and that certain features described here might
not work on earlier versions.  This section will keep track of when various
features were added to Perl 5.

=over 4

=item *

In version 5.002 before version 5.002b1h, the test.pl file was not
automatically created by xsubpp.  This means that you cannot say "make test"
to run the test script.  You will need to add the following line before the
"use extension" statement:

	use lib './blib';

=item *

In versions 5.000 and 5.001, instead of using the above line, you will need
to use the following line:

	BEGIN { unshift(@INC, "./blib") }

=item *

This document assumes that the executable named "perl" is Perl version 5.  
Some systems may have installed Perl version 5 as "perl5".

=back

=head2 DYNAMIC VERSUS STATIC

It is commonly thought that if a system does not have the capability to
dynamically load a library, you cannot build XSUB's.  This is incorrect.
You I<can> build them, but you must link the XSUB's subroutines with the
rest of Perl, creating a new executable.  This situation is similar to
Perl 4.

This tutorial can still be used on such a system.  The XSUB build mechanism
will check the system and build a dynamically-loadable library if possible,
or else a static library and then, optionally, a new statically-linked
executable with that static library linked in.

Should you wish to build a statically-linked executable on a system which
can dynamically load libraries, you may, in all the following examples,
where the command "make" with no arguments is executed, run the command
"make perl" instead.

If you have generated such a statically-linked executable by choice, then
instead of saying "make test", you should say "make test_static".  On systems
that cannot build dynamically-loadable libraries at all, simply saying "make
test" is sufficient.

=head2 EXAMPLE 1

Our first extension will be very simple.  When we call the routine in the
extension, it will print out a well-known message and return.

Run "h2xs -A -n mytest".  This creates a directory named mytest, possibly under
ext/ if that directory exists in the current working directory.  Several files
will be created in the mytest dir, including MANIFEST, Makefile.PL, mytest.pm,
mytest.xs, test.pl, and Changes.

The MANIFEST file contains the names of all the files created.

The file Makefile.PL should look something like this:

	use ExtUtils::MakeMaker;
	# See lib/ExtUtils/MakeMaker.pm for details of how to influence
	# the contents of the Makefile that is written.
	WriteMakefile(
	    'NAME'      => 'mytest',
	    'VERSION_FROM' => 'mytest.pm', # finds $VERSION
	    'LIBS'      => [''],   # e.g., '-lm'
	    'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
	    'INC'       => '',     # e.g., '-I/usr/include/other'
	);

The file mytest.pm should start with something like this:

	package mytest;

	require Exporter;
	require DynaLoader;

	@ISA = qw(Exporter DynaLoader);
	# Items to export into callers namespace by default. Note: do not export
	# names by default without a very good reason. Use EXPORT_OK instead.
	# Do not simply export all your public functions/methods/constants.
	@EXPORT = qw(

	);
	$VERSION = '0.01';

	bootstrap mytest $VERSION;

	# Preloaded methods go here.

	# Autoload methods go after __END__, and are processed by the autosplit program.

	1;
	__END__
	# Below is the stub of documentation for your module. You better edit it!

And the mytest.xs file should look something like this:

	#ifdef __cplusplus
	extern "C" {
	#endif
	#include "EXTERN.h"
	#include "perl.h"
	#include "XSUB.h"
	#ifdef __cplusplus
	}
	#endif
	
	MODULE = mytest		PACKAGE = mytest

Let's edit the .xs file by adding this to the end of the file:

	void
	hello()
		CODE:
		printf("Hello, world!\n");

Now we'll run "perl Makefile.PL".  This will create a real Makefile,
which make needs.  It's output looks something like:

	% perl Makefile.PL
	Checking if your kit is complete...
	Looks good
	Writing Makefile for mytest
	%

Now, running make will produce output that looks something like this
(some long lines shortened for clarity):

	% make
	umask 0 && cp mytest.pm ./blib/mytest.pm
	perl xsubpp -typemap typemap mytest.xs >mytest.tc && mv mytest.tc mytest.c
	cc -c mytest.c
	Running Mkbootstrap for mytest ()
	chmod 644 mytest.bs
	LD_RUN_PATH="" ld -o ./blib/PA-RISC1.1/auto/mytest/mytest.sl -b mytest.o
	chmod 755 ./blib/PA-RISC1.1/auto/mytest/mytest.sl
	cp mytest.bs ./blib/PA-RISC1.1/auto/mytest/mytest.bs
	chmod 644 ./blib/PA-RISC1.1/auto/mytest/mytest.bs

Now, although there is already a test.pl template ready for us, for this
example only, we'll create a special test script.  Create a file called hello
that looks like this:

Now we'll create a test script, test1.pl in the mytest directory.  It should
look like this:

	#! /opt/perl5/bin/perl
	
	use lib './blib';
	
	use mytest;
	
	mytest::hello();

Now we run the script and we should see the following output:

	% perl hello
	Hello, world!
	%

=head2 EXAMPLE 2

Now let's add to our extension a subroutine that will take a single argument
and return 0 if the argument is even, 1 if the argument is odd.

Add the following to the end of mytest.xs:

	int
	is_even(input)
		int	input
		CODE:
		RETVAL = (input % 2 == 0);
		OUTPUT:
		RETVAL

There must be some white space at the start of the "int input" line, and
there must not be a semi-colon at the end of the line (as you'd expect in
a C program).

Any white space may be between the "int" and "input".  It is also okay for
the four lines starting at the "CODE:" line to not be indented.  However,
for readability purposes, it is suggested that you indent them 8 spaces
(or one normal tab stop).

Now re-run make to rebuild our new shared library.

Now perform the same steps as before, generating a Makefile from the
Makefile.PL file, and running make.

In order to test that our extension works, we now need to look at the
file test.pl.  This file is set up to imitate the same kind of testing
structure that Perl itself has.  Within the test script, you perform a
number of tests to confirm the behavior of the extension, printing "ok"
when the test is correct, "not ok" when it is not.

Let's change the print statement in the BEGIN block to print "1..4" and
add the following code to the end of the file:

	print &mytest::is_even(0) == 1 ? "ok 2" : "not ok 2", "\n";
	print &mytest::is_even(1) == 0 ? "ok 3" : "not ok 3", "\n";
	print &mytest::is_even(2) == 1 ? "ok 4" : "not ok 4", "\n";

We will be calling the test script through the command "make test".  You
should see output that looks something like this:

	% make test
	PERL_DL_NONLAZY=1 /opt/perl5.002b2/bin/perl (lots of -I arguments) test.pl
	1..4
	ok 1
	ok 2
	ok 3
	ok 4
	%

=head2 WHAT HAS GONE ON?

The program h2xs is the starting point for creating extensions.  In later
examples we'll see how we can use h2xs to read header files and generate
templates to connect to C routines.

h2xs creates a number of files in the extension directory.  The file
Makefile.PL is a perl script which will generate a true Makefile to build
the extension.  We'll take a closer look at it later.

The files <extension>.pm and <extension>.xs contain the meat of the extension.
The .xs file holds the C routines that make up the extension.  The .pm file
contains routines that tell Perl how to load your extension.

Generating and invoking the Makefile created a directory blib (which stands
for "build library") in the current working directory.  This directory will
contain the shared library that we will build.  Once we have tested it, we
can install it into its final location.

Invoking the test script via "make test" did something very important.  It
invoked perl with all those -I arguments so that it could find the various
files that are part of the extension.

It is I<very> important that while you are still testing extensions that
you use "make test".  If you try to run the test script all by itself, you
will get a fatal error.

Another reason it is important to use "make test" to run your test script
is that if you are testing an upgrade to an already-existing version, using
"make test" insures that you use your new extension, not the already-existing
version.

Finally, our test scripts do two important things.  First of all, they place
the directory "blib" at the head of the @INC array.  Placing this inside a
BEGIN block assures us that Perl will look in the blib directory hierarchy
before looking in the system directories.  This could be important if you are
upgrading an already-existing extension and do not want to disturb the system
version until you are ready to install it.

When Perl sees a C<use extension;>, it searches for a file with the same name
as the use'd extension that has a .pm suffix.  If that file cannot be found,
Perl dies with a fatal error.  The default search path is contained in the
@INC array.

In our case, mytest.pm tells perl that it will need the Exporter and Dynamic
Loader extensions.  It then sets the @ISA and @EXPORT arrays and the $VERSION
scalar; finally it tells perl to bootstrap the module.  Perl will call its
dynamic loader routine (if there is one) and load the shared library.

The two arrays that are set in the .pm file are very important.  The @ISA
array contains a list of other packages in which to search for methods (or
subroutines) that do not exist in the current package.  The @EXPORT array
tells Perl which of the extension's routines should be placed into the
calling package's namespace.

It's important to select what to export carefully.  Do NOT export method names
and do NOT export anything else I<by default> without a good reason.

As a general rule, if the module is trying to be object-oriented then don't
export anything.  If it's just a collection of functions then you can export
any of the functions via another array, called @EXPORT_OK.

See L<perlmod> for more information.

The $VERSION variable is used to ensure that the .pm file and the shared
library are "in sync" with each other.  Any time you make changes to the
.pm or .xs files, you should increment the value of this variable.

=head2 EXAMPLE 3

Our third extension will take one argument as its input, round off that
value, and set the I<argument> to the rounded value.

Add the following to the end of mytest.xs:

	void
	round(arg)
		double  arg
		CODE:
		if (arg > 0.0) {
			arg = floor(arg + 0.5);
		} else if (arg < 0.0) {
			arg = ceil(arg - 0.5);
		} else {
			arg = 0.0;
		}
		OUTPUT:
		arg

Edit the Makefile.PL file so that the corresponding line looks like this:

	'LIBS'      => ['-lm'],   # e.g., '-lm'

Generate the Makefile and run make.  Change the BEGIN block to print out
"1..9" and add the following to test.pl:

	$i = -1.5; &mytest::round($i); print $i == -2.0 ? "ok 5" : "not ok 5", "\n";
	$i = -1.1; &mytest::round($i); print $i == -1.0 ? "ok 6" : "not ok 6", "\n";
	$i = 0.0; &mytest::round($i); print $i == 0.0 ? "ok 7" : "not ok 7", "\n";
	$i = 0.5; &mytest::round($i); print $i == 1.0 ? "ok 8" : "not ok 8", "\n";
	$i = 1.2; &mytest::round($i); print $i == 1.0 ? "ok 9" : "not ok 9", "\n";

Running "make test" should now print out that all nine tests are okay.

You might be wondering if you can round a constant.  To see what happens, add
the following line to test.pl temporarily:

	&mytest::round(3);

Run "make test" and notice that Perl dies with a fatal error.  Perl won't let
you change the value of constants!

=head2 WHAT'S NEW HERE?

Two things are new here.  First, we've made some changes to Makefile.PL.
In this case, we've specified an extra library to link in, in this case the
math library, libm.  We'll talk later about how to write XSUBs that can call
every routine in a library.

Second, the value of the function is being passed back not as the function's
return value, but through the same variable that was passed into the function.

=head2 INPUT AND OUTPUT PARAMETERS

You specify the parameters that will be passed into the XSUB just after you
declare the function return value and name.  The list of parameters looks
very C-like, but the lines must be indented by a tab stop, and each line
may not have an ending semi-colon.

The list of output parameters occurs after the OUTPUT: directive.  The use
of RETVAL tells Perl that you wish to send this value back as the return
value of the XSUB function.  In Example 3, the value we wanted returned was
contained in the same variable we passed in, so we listed it (and not RETVAL)
in the OUTPUT: section.

=head2 THE XSUBPP COMPILER

The compiler xsubpp takes the XS code in the .xs file and converts it into
C code, placing it in a file whose suffix is .c.  The C code created makes
heavy use of the C functions within Perl.

=head2 THE TYPEMAP FILE

The xsubpp compiler uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char *, etc.).  These rules are stored
in the typemap file ($PERLLIB/ExtUtils/typemap).  This file is split into
three parts.

The first part attempts to map various C data types to a coded flag, which
has some correspondence with the various Perl types.  The second part contains
C code which xsubpp uses for input parameters.  The third part contains C
code which xsubpp uses for output parameters.  We'll talk more about the
C code later.

Let's now take a look at a portion of the .c file created for our extension.

	XS(XS_mytest_round)
	{
	    dXSARGS;
	    if (items != 1)
		croak("Usage: mytest::round(arg)");
	    {
		double  arg = (double)SvNV(ST(0));	/* XXXXX */
		if (arg > 0.0) {
			arg = floor(arg + 0.5);
		} else if (arg < 0.0) {
			arg = ceil(arg - 0.5);
		} else {
			arg = 0.0;
		}
		sv_setnv(ST(0), (double)arg);	/* XXXXX */
	    }
	    XSRETURN(1);
	}

Notice the two lines marked with "XXXXX".  If you check the first section of
the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
INPUT section, an argument that is T_DOUBLE is assigned to the variable
arg by calling the routine SvNV on something, then casting it to double,
then assigned to the variable arg.  Similarly, in the OUTPUT section,
once arg has its final value, it is passed to the sv_setnv function to
be passed back to the calling subroutine.  These two functions are explained
in L<perlguts>; we'll talk more later about what that "ST(0)" means in the
section on the argument stack.

=head2 WARNING

In general, it's not a good idea to write extensions that modify their input
parameters, as in Example 3.  However, in order to better accomodate calling
pre-existing C routines, which often do modify their input parameters,
this behavior is tolerated.  The next example will show how to do this.

[Examples 4 and 5 have not been re-worked yet and are not included.]

=head2 SPECIFYING ARGUMENTS TO XSUBPP

After completing Example 5, we now have an easy way to simulate some
real-life libraries whose interfaces may not be the cleanest in the world.
We shall now continue with a discussion of the arguments passed to the
xsubpp compiler.

When you specify arguments in the .xs file, you are really passing three
pieces of information for each one listed.  The first piece is the order
of that argument relative to the others (first, second, etc).  The second
is the type of argument, and consists of the type declaration of the
argument (e.g., int, char*, etc).  The third piece is the exact way in
which the argument should be used in the call to the library function
from this XSUB.  This would mean whether or not to place a "&" before
the argument or not, meaning the argument expects to be passed the address
of the specified data type.

There is a difference between the two arguments in this hypothetical function:

	int
	foo(a,b)
		char	&a
		char *	b

The first argument to this function would be treated as a char and assigned
to the variable a, and its address would be passed into the function foo.
The second argument would be treated as a string pointer and assigned to the
variable b.  The I<value> of b would be passed into the function foo.  The
actual call to the function foo that xsubpp generates would look like this:

	foo(&a, b);

In other words, whatever is in the last column (or the variable name) is
what is passed into the C function.

You should take great pains to try to pass the function the type of variable
it wants, when possible.  It will save you a lot of trouble in the long run.

=head2 THE ARGUMENT STACK

If we look at any of the C code generated by any of the examples except
example 1, you will notice a number of references to ST(n), where n is
usually 0.  The "ST" is actually a macro that points to the n'th argument
on the argument stack.  ST(0) is thus the first argument passed to the
XSUB, ST(1) is the second argument, and so on.

When you list the arguments to the XSUB in the .xs file, that tell xsubpp
which argument corresponds to which of the argument stack (i.e., the first
one listed is the first argument, and so on).  You invite disaster if you
do not list them in the same order as the function expects them.

=head2 EXTENDING YOUR EXTENSION

Sometimes you might want to provide some extra methods or subroutines
to assist in making the interface between Perl and your extension simpler
or easier to understand.  These routines should live in the .pm file.
Whether they are automatically loaded when the extension itself is loaded
or only loaded when called depends on where in the .pm file the subroutine
definition is placed.

=head2 DOCUMENTING YOUR EXTENSION

There is absolutely no excuse for not documenting your extension.
Documentation belongs in the .pm file.  This file will be fed to pod2man,
and the documentation embedded within it converted to man page format,
then placed in the blib directory.  It will be copied to Perl's man
page directory when the extension is installed.

You may intersperse documentation and Perl code within the .pm file.
In fact, if you want to use method autoloading, you must do this,
as the comment inside the .pm file explains.

See L<perlpod> for more information about the pod format.

=head2 INSTALLING YOUR EXTENSION

Once your extension is complete and passes all its tests, installing it
is quite simple: you simply run "make install".  You will either need 
to have write permission into the directories where Perl is installed,
or ask your system administrator to run the make for you.

=head2 SEE ALSO

For more information, consult L<perlguts>, L<perlxs>, L<perlmod>,
and L<perlpod>.

=head2 Author

Jeff Okamoto <okamoto@corp.hp.com>

Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas Koenig,
and Tim Bunce.

=head2 Last Changed

1996/1/19

